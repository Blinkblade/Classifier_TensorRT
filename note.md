1. 在开始编写一个类/功能时最好先分配一个命名空间
同样,在引入其他头文件后,假设没有using namespace,那么对应命名空间中的功能也需要添加命名空间才可以调用
包括标准库函数也需要using namespace或指定作用域

2. 如果可用可以使用find packge构建cmakelist模块,例如
opencv 官网提供:
    cmake_minimum_required(VERSION 2.8)
    project( DisplayImage )
    find_package( OpenCV REQUIRED )
    include_directories( ${OpenCV_INCLUDE_DIRS} )
    add_executable( DisplayImage DisplayImage.cpp )
    target_link_libraries( DisplayImage ${OpenCV_LIBS} )

3. CMAKE 交叉编译cuda与cpp项目时应当注意:
最好的规则应该遵循:
                
                            ||+++ test_cuda.cu

            test_cuda.hpp+++

                            ||+++ test_cuda.cpp
的依赖规范,

test_cuda.hpp中声明所有的函数接口,然后在test_cuda.cu中实现核函数并通过test_cuda.hpp提供的接口把核函数封装到对应接口中,在封装过程中要配置好相关cuda语法。
然后通过test_cuda.cpp从test_cuda.hpp接口中调用test_cuda.cu封装好的另一个接口,实现在cpp中对cuda程序的调用。

我们不应该在cpp文件中引入任何cu或cuh，因为g++无法编译cuda相关语法。正确的做法是先写一个hpp声明所有需要的函数，然后分别在cu文件中引入实现cuda语法以及在cpp文件中引入hpp并实现cpp语法，如果cpp中需要用到核函数，应该通过.hpp中声明的接口调用而不能引入.cu直接调用。

4. 最好不要在头文件中直接实现函数定义,可能会遇到多重定义的错误:
由于混合编译时会使用nvcc和g++两个编译器分别编译cuda和cpp文件,
因为 timer_gpu_test 函数在头文件 test_cuda.hpp 中被定义（实现了函数体），而这个头文件被多个源文件包含。每当一个 .cpp 或 .cu 文件包含了 test_cuda.hpp，编译器都会在那个编译单元中创建一个 timer_gpu_test 的实例。最终在链接阶段，链接器发现有多个相同符号的定义，从而引发了错误。(nvcc和g++分别编译了两个.o都包含定义的好函数实现)


5. & 与 const传值
使用 `cv::Mat &src` 而非 `cv::Mat src`
- **性能**：`cv::Mat` 对象通常包含图像数据，这可能是大量数据。直接传递 `cv::Mat`（值传递）将导致复制整个对象，包括其数据，这是非常消耗资源的。相比之下，传递引用（`cv::Mat &src`）仅传递对象的引用，不涉及数据复制，因此效率更高。
- **功能**：使用引用传递还允许函数内部修改原始 `Mat` 对象。如果函数意图是修改原始矩阵，那么这是必需的。如果函数只是读取而不修改原始矩阵，通常会将其声明为 `const cv::Mat& src` 来保证不会对输入数据进行修改。

使用 `const int& tarH` 和 `const int& tarW` 而非 `int tarH` 和 `int tarW`
- **内存和性能**：理论上，对于基本数据类型（如 `int`），使用值传递通常与引用传递相比，性能差异不大，甚至值传递更优，因为引用可能会导致间接访问。然而，某些情况下（特别是在复杂系统或大型应用中），统一使用引用传递（尤其是带有 `const`）可以减少内存使用，并防止函数意外修改数据，从而增加代码的可预测性。
- **编程风格和一致性**：在某些代码库中，对于所有参数一律使用 `const &` 可以保持一致的编程风格，即使对于那些通过值传递可能更高效的基本类型。这也使得以后更改参数类型（比如从 `int` 改为较大的数据类型）时不需要修改函数接口。

6. 
在 C++ 中，选择使用普通类型、指针类型或智能指针类型来定义类的成员变量是基于不同的设计考虑和需求。每种类型的使用都有其特定的目的和场景。以下是各种类型使用的一些常见理由和情境：

### 普通类型（Primitives and Objects）

- **用途**：当你需要一个对象或基本数据类型（如 `int`, `double`, `float`, `std::string` 等）作为类的一部分，并且这个对象或数据类型的生命周期与类对象紧密相关时，通常会直接作为值类型成员存在。
- **特点**：这些类型的对象在类的对象被创建时自动构造，并在类的对象被销毁时自动销毁。使用这种方式可以简化内存管理，因为不需要手动管理这些成员的生命周期。
- **示例**：`std::string m_name;`, `int m_age;`。

### 指针类型

- **用途**：指针通常用于以下几种情况：
  - **动态内存管理**：当你需要在运行时根据需要分配或释放内存时。
  - **多态行为**：当你需要通过基类指针持有派生类对象，以便实现多态行为。
  - **共享或传递对象所有权**：当一个对象由多个控制源共享或其所有权需要在不同对象或函数间传递时。
- **特点**：指针提供了灵活的内存管理和对象访问方式，但使用不当容易导致内存泄露、悬挂指针等问题。
- **示例**：`float* m_data;`, `Model* m_model;`。

### 智能指针类型

- **用途**：
  - **自动内存管理**：智能指针如 `std::shared_ptr` 和 `std::unique_ptr` 可以自动管理内存，帮助避免内存泄漏。
  - **所有权语义清晰**：`std::unique_ptr` 表示唯一所有权，而 `std::shared_ptr` 表示共享所有权。
  - **资源的安全共享**：尤其是在多线程环境中或多个对象需要引用同一资源时。
- **特点**：智能指针通过引用计数（对于 `std::shared_ptr`）或作用域规则（对于 `std::unique_ptr`）自动释放所持资源，从而减少直接指针操作引发的问题。
- **示例**：`std::shared_ptr<nvinfer1::IExecutionContext> m_context;`, `std::unique_ptr<Model> m_model;`。

### 总结

- **选择普通类型**：当数据成员是基本类型或对象，其生命周期自然与对象对齐时。
- **选择指针类型**：需要动态分配内存，或者需要实现多态时。
- **选择智能指针类型**：需要自动内存管理或在对象之间共享资源时。

在现代 C++ 设计中，推荐尽量使用智能指针来管理资源和动态分配的内存，以减少内存泄漏和其他资源管理错误的风险。普通指针应在知道如何安全地管理资源的前提下慎用。

7. vtable报错一般意味着类中定义的函数没有实现, 在cu cpp实现函数(非类内函数),如果已经指定了namespace则前面不能再加namespace ::.
使用cmake组织项目每次添加新文件时需要重新cmake

